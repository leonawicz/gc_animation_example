<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Matthew Leonawicz" />


<title>Making still frames for great circle animations in R</title>

<script src="libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/lumen.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style type="text/css">
/* padding for bootstrap navbar */
body {
padding-top: 50px;
padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar) */
.section h2 {
padding-top: 55px;
margin-top: -55px;
}
.section h3 {
padding-top: 55px;
margin-top: -55px;
}
/* don't use link color in navbar */
.dropdown-menu>li>a {
color: black;
}
/* some padding for disqus */
#disqus_thread {
margin-top: 45px;
}
p {
  text-align: justify;
}
img.centered {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.jqstooltip {
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}

</style>
<link rel="stylesheet" href="libs/font-awesome-4.1.0/css/font-awesome.min.css"/>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #303030; color: #cccccc; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; }
td.sourceCode { padding-left: 5px; }
pre, code { color: #cccccc; background-color: #303030; }
code > span.kw { color: #f0dfaf; } /* Keyword */
code > span.dt { color: #dfdfbf; } /* DataType */
code > span.dv { color: #dcdccc; } /* DecVal */
code > span.bn { color: #dca3a3; } /* BaseN */
code > span.fl { color: #c0bed1; } /* Float */
code > span.ch { color: #dca3a3; } /* Char */
code > span.st { color: #cc9393; } /* String */
code > span.co { color: #7f9f7f; } /* Comment */
code > span.ot { color: #efef8f; } /* Other */
code > span.al { color: #ffcfaf; } /* Alert */
code > span.fu { color: #efef8f; } /* Function */
code > span.er { color: #c3bf9f; } /* Error */
code > span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
code > span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code > span.sc { color: #dca3a3; } /* SpecialChar */
code > span.vs { color: #cc9393; } /* VerbatimString */
code > span.ss { color: #cc9393; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { color: #f0dfaf; } /* ControlFlow */
code > span.op { color: #f0efd0; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code > span.at { } /* Attribute */
code > span.do { color: #7f9f7f; } /* Documentation */
code > span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code > span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code > span.in { color: #7f9f7f; font-weight: bold; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>



</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<div class="container-fluid main-container">

<!-- tabsets -->
<script src="libs/navigation-1.0/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->





<div class="navbar navbar-default navbar-fixed-top">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Great circle animation examples</a>
      </div>
      <div class="navbar-collapse collapse navbar-responsive-collapse">
        <ul class="nav navbar-nav">
          <li><a href="app_traffic_example.html">Moving arcs on rotating Earth</a></li>

          <li><a href="http://leonawicz.github.io">All Projects</a></li>
        </ul>
        <ul class="nav navbar-nav navbar-right">
          <a class="btn btn-link" href="https://github.com/leonawicz/gc_animation_example">
            <i class="fa fa-github fa-lg"></i>
            Github
          </a>
        </ul>
      </div><!--/.nav-collapse -->
    </div>
  </div>

<div class="fluid-row" id="header">


<h1 class="title">Making still frames for great circle animations in R</h1>
<h4 class="author"><em>Matthew Leonawicz</em></h4>

</div>


<p>Here I share <iframe style="float: right; padding-left: 10px; padding-right: 10px" width="560" height="315" src="https://www.youtube.com/watch?v=uQYR91qixgo" frameborder="0" allowfullscreen></iframe> R code I used to produce <a href="https://www.youtube.com/embed/uQYR91qixgo">animated great circle arcs</a> on top of a rotating 3D Earth. The code is not entirely reproducible but you should be able to use what is shared here to create your own video frames given your unique data and computing environment and resources.</p>
<p>When I make great circle animations, at the core of the process is always an R function that transforms a series of coordinates describing points along a great circle arc into multiple series of great circle arc segments. The goal is simple: plot a series of line segments, saving each plot as a subsequent still frame, rather than plotting the original entire arc as a single plot. The input is generally a data table (much faster to work with than a data frame if you have a lot of data) with longitude and latitude columns where the coordinates in each row describe a subsequent point along one of my paths. I also use a third column to provide a unique group ID for each path to keep them distinct.</p>
<p>Before getting to this process, here is some example code of how I formatted my data this way when using the <code>geosphere</code> package. Do not get bogged down in the details here. This is just an example for fuller context regarding my specific animation referenced above and I will not be focusing on it. Your data will be quite different. You will have to arrange it similarly, but obviously it will be in a different context.</p>
<div id="data-prep-example" class="section level3">
<h3>Data prep example</h3>
<p>As you can see below, all you need is a data frame with columns of longitude and latitude. I created a <code>SpatialPoints</code> object from these. In my case I wanted to connect great circle arcs between each of two specific locations and all other locations in my data set. I marked the row indices for these two locations.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)
<span class="kw">library</span>(geosphere)

<span class="kw">load</span>(<span class="st">&quot;data.RData&quot;</span>)  <span class="co"># a data frame, d, containing &#39;long&#39; and &#39;lat&#39; columns</span>
p &lt;-<span class="st"> </span><span class="kw">SpatialPoints</span>(<span class="kw">cbind</span>(d$long, d$lat), <span class="dt">proj4string =</span> <span class="kw">CRS</span>(<span class="st">&quot;+proj=longlat +datum=WGS84&quot;</span>))
idx1 &lt;-<span class="st"> </span><span class="dv">69</span>  <span class="co"># great circles from coords in all other rows to coords in this row</span>
idx2 &lt;-<span class="st"> </span><span class="dv">2648</span>  <span class="co"># as above</span>

get_paths &lt;-<span class="st"> </span>function(x, idx, ...) {
    gcInt &lt;-<span class="st"> </span>function(x, x1, x2) {
        x &lt;-<span class="st"> </span><span class="kw">gcIntermediate</span>(x[x1, ], x[x2, ], ...)
        if (<span class="kw">is.list</span>(x)) {
            x &lt;-<span class="st"> </span>x %&gt;%<span class="st"> </span>purrr::<span class="kw">map2</span>(<span class="kw">c</span>(x1, x1 +<span class="st"> </span><span class="fl">0.5</span>), ~<span class="kw">data.frame</span>(.x, .y)) %&gt;%<span class="st"> </span>
<span class="st">                </span>bind_rows %&gt;%<span class="st"> </span><span class="kw">setnames</span>(<span class="kw">c</span>(<span class="st">&quot;long&quot;</span>, <span class="st">&quot;lat&quot;</span>, <span class="st">&quot;group&quot;</span>))
        } else x &lt;-<span class="st"> </span><span class="kw">data.frame</span>(x, x1) %&gt;%<span class="st"> </span><span class="kw">setnames</span>(<span class="kw">c</span>(<span class="st">&quot;long&quot;</span>, <span class="st">&quot;lat&quot;</span>, <span class="st">&quot;group&quot;</span>))
        x
    }
    purrr::<span class="kw">map</span>(<span class="kw">setdiff</span>(<span class="dv">1</span>:<span class="kw">length</span>(x), idx), ~<span class="kw">gcInt</span>(x, .x, idx)) %&gt;%<span class="st"> </span>bind_rows
}

paths1 &lt;-<span class="st"> </span><span class="kw">get_paths</span>(p, idx1, <span class="dt">addStartEnd =</span> <span class="ot">TRUE</span>)
paths2 &lt;-<span class="st"> </span><span class="kw">get_paths</span>(p, idx2, <span class="dt">addStartEnd =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><code>get_paths</code> uses <code>gcIntermediate</code> from the <code>geosphere</code> package to obtain vectors of points defining great circle arcs between my two locations and all others. The resulting data frame has columns, <code>long</code>, <code>lat</code>, and <code>group</code>. I do not break the arcs at the dateline because I intend to draw them on a 3D globe, but if I were making a flat map I would do so. This is why the function handles the case of list output from <code>gcIntermediate</code> and adjusts the group ID by add 0.5 to one group.</p>
<p>Already more than enough details. You can see what I am going for though. Given my data, I want to end up with columns of longitude and latitude defining great circle arcs and broken out by unique group IDs. I show this because it’s highly likely you will want to use <code>geosphere</code> in a similar way even if you won’t be connecting points in the same way I am here.</p>
</div>
<div id="transforming-great-circle-arcs-into-segments" class="section level3">
<h3>Transforming great circle arcs into segments</h3>
<p>Okay. You have your data in the right format. Now you want to break up your groups of great circle arcs into a larger number of nested subgroups of great circle arc segments. Let’s get some basic prep out of the way. Here are the packages I am using.</p>
<div id="the-steup" class="section level4">
<h4>The steup</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(parallel)
<span class="kw">library</span>(gridExtra)
<span class="kw">library</span>(raster)
<span class="kw">library</span>(data.table)
<span class="kw">library</span>(dplyr)
<span class="kw">library</span>(ggplot2)

eb &lt;-<span class="st"> </span><span class="kw">element_blank</span>()
theme_blank &lt;-<span class="st"> </span><span class="kw">theme</span>(<span class="dt">axis.line =</span> eb, <span class="dt">axis.text.x =</span> eb, <span class="dt">axis.text.y =</span> eb, <span class="dt">axis.ticks =</span> eb,
    <span class="dt">axis.title.x =</span> eb, <span class="dt">axis.title.y =</span> eb, <span class="dt">legend.position =</span> <span class="st">&quot;none&quot;</span>, <span class="dt">panel.background =</span> eb,
    <span class="dt">panel.border =</span> eb, <span class="dt">panel.grid.major =</span> eb, <span class="dt">panel.grid.minor =</span> eb, <span class="dt">plot.background =</span> <span class="kw">element_rect</span>(<span class="dt">colour =</span> <span class="st">&quot;transparent&quot;</span>,
        <span class="dt">fill =</span> <span class="st">&quot;transparent&quot;</span>))

world &lt;-<span class="st"> </span><span class="kw">map_data</span>(<span class="st">&quot;world&quot;</span>)</code></pre></div>
<p>The <code>ggplot2</code> theme will allow for plotting without all the extraneous stuff like margins and axes and colors I don’t want on my Earth. The world map is an aside and has nothing to do with the great circles. I include it here because it was part of my animation. It will be used from plotting the backdrop of nation boundaries on the globe. Having these underneath the great circle animation is helpful for geographic visual orientation.</p>
<p>It’s not clear yet, but the reason for including the <code>raster</code> package is because I also use a rasterized map layer of the earth’s surface as the bottom layer underneath the nation boundaries. This is also an aside. It doesn’t have anything to do with the great circle animation.</p>
<p>Yes, I am using R’s built-in <code>parallel</code> package. I happen to be do at least the parallelized operations in this project on a Linux server with 32 CPUs and 260 GB RAM. I’m sorry to say but I can’t help you if you want to do this on a local Windows pc for example. If you rework the code for a much more restrictive environment, depending on your data, you may find yourself waiting forever for your output. I just do not recommend doing this type of thing outside of a beefy server environment, at least if time is something you value.</p>
<p>Now, getting to the core of the process for real this time. Here is the actual function I used for the above animation to break great circle arcs into smaller segments.</p>
</div>
<div id="the-main-function" class="section level4">
<h4>The main function</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df_segs &lt;-<span class="st"> </span>function(d, seg.size, n.frames, <span class="dt">replicates =</span> <span class="dv">1</span>, <span class="dt">direction =</span> <span class="st">&quot;fixed&quot;</span>) {
    n &lt;-<span class="st"> </span><span class="kw">nrow</span>(d)
    if (n &lt;<span class="st"> </span><span class="dv">3</span>)
        <span class="kw">stop</span>(<span class="st">&quot;Data not appropriate for this operation.&quot;</span>)
    if (seg.size &lt;<span class="st"> </span><span class="dv">3</span>)
        <span class="kw">stop</span>(<span class="st">&quot;Segment size too small.&quot;</span>)
    z &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="kw">runif</span>(<span class="dv">2</span>, <span class="dv">2</span>, seg.size))
    z[z &gt;<span class="st"> </span>n] &lt;-<span class="st"> </span>n
    n1 &lt;-<span class="st"> </span><span class="kw">ceiling</span>(<span class="kw">diff</span>(<span class="kw">c</span>((z[<span class="dv">1</span>] -<span class="st"> </span>z[<span class="dv">2</span>]), n))/z[<span class="dv">1</span>])
    if (n.frames -<span class="st"> </span>n1 &lt;<span class="st"> </span><span class="dv">100</span>)
        <span class="kw">stop</span>(<span class="st">&quot;Insufficient frames&quot;</span>)
    offset &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">0</span>:(n.frames -<span class="st"> </span>n1), replicates)

    f &lt;-<span class="st"> </span>function(k, d, n, n1, z, offset) {
        ind2 &lt;-<span class="st"> </span>z[<span class="dv">1</span>] *<span class="st"> </span>k
        ind1 &lt;-<span class="st"> </span><span class="kw">max</span>(ind2 -<span class="st"> </span>z[<span class="dv">2</span>], <span class="dv">1</span>)
        if (ind2 &gt;<span class="st"> </span>n)
            ind2 &lt;-<span class="st"> </span>n
        d &lt;-<span class="st"> </span><span class="kw">slice</span>(d, ind1:ind2)
        purrr::<span class="kw">map</span>(offset, ~<span class="kw">mutate</span>(d, <span class="dt">group =</span> <span class="kw">ifelse</span>(replicates ==<span class="st"> </span><span class="dv">1</span>, group,
            group +<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">sprintf</span>(<span class="st">&quot;.%d&quot;</span>, k))), <span class="dt">frameID =</span> .x +<span class="st"> </span>k)) %&gt;%<span class="st"> </span>bind_rows
    }

    if (direction ==<span class="st"> &quot;reverse&quot;</span>)
        d &lt;-<span class="st"> </span><span class="kw">mutate</span>(d, <span class="dt">long =</span> <span class="kw">rev</span>(long), <span class="dt">lat =</span> <span class="kw">rev</span>(lat))
    if (direction ==<span class="st"> &quot;random&quot;</span> &amp;&amp;<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>) &lt;<span class="st"> </span><span class="dv">0</span>)
        d &lt;-<span class="st"> </span><span class="kw">mutate</span>(d, <span class="dt">long =</span> <span class="kw">rev</span>(long), <span class="dt">lat =</span> <span class="kw">rev</span>(lat))
    d &lt;-<span class="st"> </span>purrr::<span class="kw">map</span>(<span class="dv">1</span>:n1, ~<span class="kw">f</span>(.x, d, n, n1, z, offset)) %&gt;%<span class="st"> </span>bind_rows %&gt;%<span class="st"> </span><span class="kw">arrange</span>(group,
        frameID)
    d
}

n.frames &lt;-<span class="st"> </span><span class="dv">900</span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
paths2 &lt;-<span class="st"> </span><span class="kw">mutate</span>(paths2, <span class="dt">group =</span> group +<span class="st"> </span><span class="kw">max</span>(paths1$group))
paths &lt;-<span class="st"> </span><span class="kw">bind_rows</span>(paths1, paths2) %&gt;%<span class="st"> </span><span class="kw">split</span>(.$group)</code></pre></div>
<p>Going through the code, you can see it requires a minimum of 100 desired frames (which would make for quite a short video). You can tweak the maximum number of points in a segment. The minimum is always two. Each segment will vary in length uniformly between the minimum and maximum.</p>
<p>You can leave the data as is, with <code>direction=&quot;fixed&quot;</code>. This assumes the ordering of points/rows pertaining to each group is intended to show direction. Segments will be assembled in the same order. Alternatively, you can reverse or even randomize the order if it doesn’t matter for the given data.</p>
<p>This is just one example function. You can make your own if this one does not generate the type of segments or provide the kind of random variation in segments you would like.</p>
<p>Let’s go with 900 frames, which will result in about a 30 second video. Recall that in my case I had two different data sets. I combine them at the end of the above code snippet.</p>
<p>Here I make the new table below. It has a subgroup ID column as well as a frame ID column. Group ID is now a decimal. To the left is the original great circle ID. To the right is the sequential segment ID. The latter is random and not all great circle arcs are broken up into the same number of segments. Some cover more rows of the table than others. They do not match up with the frame IDs and some recycling may be required if the number of desired frames is large enough.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">paths &lt;-<span class="st"> </span><span class="kw">mclapply</span>(paths, df_segs, <span class="dt">seg.size =</span> <span class="dv">5</span>, <span class="dt">n.frames =</span> n.frames, <span class="dt">replicates =</span> <span class="dv">1</span>,
    <span class="dt">direction =</span> <span class="st">&quot;random&quot;</span>, <span class="dt">mc.cores =</span> <span class="dv">32</span>) %&gt;%<span class="st"> </span>bind_rows</code></pre></div>
<p>Alternatively, code like this will perform the same operation without using parallel processing. This may not be terribly problematic if the data set is not too large. I show this for comparison. But the need for parallel will be much greater in later steps.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">paths &lt;-<span class="st"> </span>paths %&gt;%<span class="st"> </span><span class="kw">split</span>(.$group) %&gt;%<span class="st"> </span>purrr::<span class="kw">map</span>(~<span class="kw">df_segs</span>(.x, <span class="dv">5</span>, n.frames, <span class="dt">replicates =</span> <span class="dv">1</span>,
    <span class="dt">direction =</span> <span class="st">&quot;random&quot;</span>)) %&gt;%<span class="st"> </span>bind_rows</code></pre></div>
</div>
</div>
<div id="aside-the-background-layer" class="section level3">
<h3>Aside: the background layer <img style="float: right; padding-left: 10px; padding-right: 10px" src="tile.png" width="300"/></h3>
</div>
<div id="section" class="section level2">
<h2></h2>
<div id="where-i-got-the-data" class="section level4">
<h4>Where I got the data</h4>
<p>I use a rasterized bathymetry surface based on a csv file I downloaded by using the <code>marmap</code> package. I won’t discuss that here. Please see the <code>marmap</code> package for details and examples if this is important. It is straightforward to use that package to download a local copy of a subregion of the data (or the whole map) at a specified resolution.</p>
</div>
</div>
<div id="section-1" class="section level2">
<h2></h2>
<div id="projecting-background-layer-to-3d" class="section level4">
<h4>Projecting background layer to 3D</h4>
<p>The <code>project_to_hemisphere</code> function below projects points onto the 3D earth and identifies which ones are within the hemisphere field of view given the centroid focal point. Identifying the half which are out of view in any given frame allows me to toss them out for some added efficiency. This is not actually a slow process. The conversion of coordinates is complex or demanding. The slow part is drawing the high resolution orthographic projection maps with <code>ggplot2</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d.bath &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;marmap_coord_-180;-90;180;90_res_10.csv&quot;</span>) %&gt;%<span class="st"> </span>data.table %&gt;%<span class="st"> </span>
<span class="st">    </span><span class="kw">setnames</span>(<span class="kw">c</span>(<span class="st">&quot;long&quot;</span>, <span class="st">&quot;lat&quot;</span>, <span class="st">&quot;z&quot;</span>))
r &lt;-<span class="st"> </span><span class="kw">raster</span>(<span class="kw">extent</span>(-<span class="dv">180</span>, <span class="dv">180</span>, -<span class="dv">90</span>, <span class="dv">90</span>), <span class="dt">res =</span> <span class="dv">1</span>/<span class="dv">6</span>)
<span class="kw">projection</span>(r) &lt;-<span class="st"> &quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs&quot;</span>
r &lt;-<span class="st"> </span><span class="kw">setValues</span>(r, d.bath$z)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">project_to_hemisphere &lt;-<span class="st"> </span>function(lat, long, lat0, long0) {
    hold &lt;-<span class="st"> </span><span class="kw">c</span>(lat, long)
    x &lt;-<span class="st"> </span>(pi/<span class="dv">180</span>) *<span class="st"> </span><span class="kw">c</span>(lat, lat0, long -<span class="st"> </span>long0)
    inview &lt;-<span class="st"> </span><span class="kw">sin</span>(x[<span class="dv">1</span>]) *<span class="st"> </span><span class="kw">sin</span>(x[<span class="dv">2</span>]) +<span class="st"> </span><span class="kw">cos</span>(x[<span class="dv">1</span>]) *<span class="st"> </span><span class="kw">cos</span>(x[<span class="dv">2</span>]) *<span class="st"> </span><span class="kw">cos</span>(x[<span class="dv">3</span>]) &gt;<span class="st"> </span><span class="dv">0</span>
    <span class="kw">data.table</span>(<span class="dt">long =</span> hold[<span class="dv">2</span>], <span class="dt">lat =</span> hold[<span class="dv">1</span>], <span class="dt">inview =</span> inview)
}</code></pre></div>
</div>
<div id="prepare-for-plotting" class="section level3">
<h3>Prepare for plotting</h3>
<p>I want a 120-frame period, which is about four seconds of video, in which time I will complete one rotation of the earth. I define a sequence of longitude values, but this I allow to repeat for the total number of video frames, <code>n.frames</code>, specified earlier. Note that I keep the latitude focus (41 degrees) constant in this animation, but there is no reason this cannot vary as well. In the <code>save_maps</code> function below, there is a hard-coded 23.4-degree fixed orientation, but this is something that can also be made variable.</p>
<p>While the data we are interested in - the great circle arc segments - will plot sequentially over a series of 900 frames, both the nation boundaries and bathymetry surface map backdrops are constant so I only need to produce enough frames (120) for one rotation of each of those layers.</p>
<p>I split the path segments table on the frame ID. I will generate still frames in parallel.</p>
<p>In this animation I had originally chosen to aggregate my 10-minute resolution bathymetry surface from the <code>marmap</code> package because that resolution was a bit too fine and even in parallel it was taking an extremely long time for <code>ggplot2</code> to draw the orthographic projection background maps. If I understand correctly, it is drawing a ton of tiny, filled polygons. It really grinds to a halt if you have a massive amount of them.</p>
<div id="some-setup" class="section level4">
<h4>Some setup</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n.period &lt;-<span class="st"> </span><span class="dv">120</span>
lon_seq &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">360</span>, <span class="dt">length.out =</span> n.period +<span class="st"> </span><span class="dv">1</span>)[-(n.period +<span class="st"> </span><span class="dv">1</span>)], <span class="dt">length =</span> n.frames)
lat_seq &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">41</span>, <span class="kw">length</span>(lon_seq))
paths &lt;-<span class="st"> </span>paths %&gt;%<span class="st"> </span><span class="kw">split</span>(.$frameID)
d.bath.agg &lt;-<span class="st"> </span>r %&gt;%<span class="st"> </span><span class="kw">aggregate</span>(<span class="dv">2</span>) %&gt;%<span class="st"> </span>rasterToPoints %&gt;%<span class="st"> </span>data.table %&gt;%<span class="st"> </span><span class="kw">setnames</span>(<span class="kw">c</span>(<span class="st">&quot;long&quot;</span>,
    <span class="st">&quot;lat&quot;</span>, <span class="st">&quot;z&quot;</span>))</code></pre></div>
<p>Next, in parallel across frames, I project my rasterized background map cells to the 3D surface and retain only the ones which are in view in a given frame as the earth spins. I use the full range of elevation data to retain a constant color palette mapping as cells at different extreme elevations move in and out of the field of view as the earth rotates. I store the range in <code>z.range</code>. I add a frame ID column. Finally I add a frame ID column for the nation boundaries table. The data is constant, but simply needs to be plotted 120 times in 3-degree shifts.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d.tiles &lt;-<span class="st"> </span><span class="kw">mclapply</span>(<span class="dv">1</span>:n.period, function(i, x, lon, lat) {
    <span class="kw">left_join</span>(x, <span class="kw">project_to_hemisphere</span>(x$lat, x$long, lat[i], lon[i])) %&gt;%<span class="st"> </span><span class="kw">filter</span>(inview) %&gt;%<span class="st"> </span>
<span class="st">        </span>dplyr::<span class="kw">select</span>(-inview) %&gt;%<span class="st"> </span><span class="kw">mutate</span>(<span class="dt">frameID =</span> i)
}, <span class="dt">x =</span> d.bath.agg, <span class="dt">lat =</span> lat_seq, <span class="dt">lon =</span> lon_seq, <span class="dt">mc.cores =</span> <span class="dv">32</span>)

z.range &lt;-<span class="st"> </span>purrr::<span class="kw">map</span>(d.tiles, ~<span class="kw">range</span>(.x$z, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)) %&gt;%<span class="st"> </span>unlist %&gt;%<span class="st"> </span>range
d.world &lt;-<span class="st"> </span>purrr::<span class="kw">map</span>(<span class="dv">1</span>:n.period, ~<span class="kw">mutate</span>(world, <span class="dt">frameID =</span> .x))</code></pre></div>
</div>
</div>
<div id="save-plots" class="section level3">
<h3>Save plots</h3>
<p>I’ve showed the most important of two functions for making my great circle animation, <code>df_segs</code>, which I use to transformed a table of grouped rows of great circle arc coordinates into a much larger one with nested, grouped, sequential arc segments. The other critical function is <code>save_maps</code>.</p>
<p>Here I have generalized it a bit by adding a <code>type</code> argument. It is primarily used for iterating over the data for each frame in a table produced by <code>df_segs</code> (the default <code>type=&quot;network&quot;</code>). This saves a map image of sequential great circle arc segments for each frame.</p>
<p>I added the options, <code>type=&quot;maplines&quot;</code> and <code>type=&quot;maptiles&quot;</code>. The former is for the nation boundaries and the latter is for the rasterized map surface.</p>
<p>I call the function in parallel three times to cover each type of output. I generate 120 frames (one earth rotation in three-degree increments) of both the nation boundaries and the surface tiles. The latter takes by far the longest amount of time to process, far longer than even the 900 frames of network traffic itself.</p>
<div id="the-other-main-function" class="section level4">
<h4>The other main function</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">save_maps &lt;-<span class="st"> </span>function(x, lon_seq, lat_seq, <span class="dt">col =</span> <span class="ot">NULL</span>, <span class="dt">type =</span> <span class="st">&quot;network&quot;</span>, <span class="dt">z.range =</span> <span class="ot">NULL</span>) {
    if (<span class="kw">is.null</span>(col))
        col &lt;-<span class="st"> </span>switch(type, <span class="dt">network =</span> <span class="kw">c</span>(<span class="st">&quot;#FFFFFF25&quot;</span>, <span class="st">&quot;#1E90FF25&quot;</span>, <span class="st">&quot;#FFFFFF&quot;</span>,
            <span class="st">&quot;#1E90FF50&quot;</span>), <span class="dt">maptiles =</span> <span class="kw">c</span>(<span class="st">&quot;black&quot;</span>, <span class="st">&quot;steelblue4&quot;</span>), <span class="dt">maplines =</span> <span class="st">&quot;white&quot;</span>)
    i &lt;-<span class="st"> </span>x$frameID[<span class="dv">1</span>]
    if (type ==<span class="st"> &quot;network&quot;</span>)
        x.lead &lt;-<span class="st"> </span><span class="kw">group_by</span>(x, group) %&gt;%<span class="st"> </span><span class="kw">slice</span>(<span class="kw">n</span>())
    g &lt;-<span class="st"> </span><span class="kw">ggplot</span>(x, <span class="kw">aes</span>(long, lat))
    if (type ==<span class="st"> &quot;maptiles&quot;</span>) {
        if (<span class="kw">is.null</span>(z.range))
            z.range &lt;-<span class="st"> </span><span class="kw">range</span>(x$z, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
        g &lt;-<span class="st"> </span><span class="kw">ggplot</span>(x, <span class="kw">aes</span>(long, lat, <span class="dt">fill =</span> z)) +<span class="st"> </span><span class="kw">geom_tile</span>() +<span class="st"> </span><span class="kw">scale_fill_gradientn</span>(<span class="dt">colors =</span> col,
            <span class="dt">limits =</span> z.range)
    } else {
        g &lt;-<span class="st"> </span><span class="kw">ggplot</span>(x, <span class="kw">aes</span>(long, lat, <span class="dt">group =</span> group))
        if (type ==<span class="st"> &quot;maplines&quot;</span>)
            g &lt;-<span class="st"> </span>g +<span class="st"> </span><span class="kw">geom_path</span>(<span class="dt">colour =</span> col)
        if (type ==<span class="st"> &quot;network&quot;</span>)
            g &lt;-<span class="st"> </span>g +<span class="st"> </span><span class="kw">geom_path</span>(<span class="dt">colour =</span> col[<span class="dv">2</span>]) +<span class="st"> </span><span class="kw">geom_path</span>(<span class="dt">colour =</span> col[<span class="dv">1</span>]) +<span class="st"> </span>
<span class="st">                </span><span class="kw">geom_point</span>(<span class="dt">data =</span> x.lead, <span class="dt">colour =</span> col[<span class="dv">3</span>], <span class="dt">size =</span> <span class="fl">0.6</span>) +<span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">data =</span> x.lead,
                <span class="dt">colour =</span> col[<span class="dv">4</span>], <span class="dt">size =</span> <span class="fl">0.3</span>)
    }
    g &lt;-<span class="st"> </span>g +<span class="st"> </span>theme_blank +<span class="st"> </span><span class="kw">coord_map</span>(<span class="st">&quot;ortho&quot;</span>, <span class="dt">orientation =</span> <span class="kw">c</span>(lat_seq[i], lon_seq[i],
        <span class="fl">23.4</span>))
    <span class="kw">dir.create</span>(outDir &lt;-<span class="st"> </span><span class="kw">file.path</span>(<span class="st">&quot;frames&quot;</span>, type), <span class="dt">recursive =</span> <span class="ot">TRUE</span>, <span class="dt">showWarnings =</span> <span class="ot">FALSE</span>)
    <span class="kw">png</span>(<span class="kw">sprintf</span>(<span class="kw">paste0</span>(outDir, <span class="st">&quot;/&quot;</span>, type, <span class="st">&quot;_%03d.png&quot;</span>), i), <span class="dt">width =</span> <span class="dv">4</span> *<span class="st"> </span><span class="dv">1920</span>,
        <span class="dt">height =</span> <span class="dv">4</span> *<span class="st"> </span><span class="dv">1080</span>, <span class="dt">res =</span> <span class="dv">300</span>, <span class="dt">bg =</span> <span class="st">&quot;transparent&quot;</span>)
    <span class="kw">print</span>(g)
    <span class="kw">dev.off</span>()
    <span class="ot">NULL</span>
}

<span class="kw">mclapply</span>(paths, save_maps, lon_seq, lat_seq, <span class="dt">type =</span> <span class="st">&quot;network&quot;</span>, <span class="dt">mc.cores =</span> <span class="dv">30</span>)
<span class="kw">mclapply</span>(d.world, save_maps, lon_seq, lat_seq, <span class="dt">type =</span> <span class="st">&quot;maplines&quot;</span>, <span class="dt">mc.cores =</span> <span class="dv">30</span>)
<span class="kw">mclapply</span>(d.tiles, save_maps, lon_seq, lat_seq, <span class="dt">type =</span> <span class="st">&quot;maptiles&quot;</span>, <span class="dt">z.range =</span> z.range,
    <span class="dt">mc.cores =</span> <span class="dv">30</span>)</code></pre></div>
</div>
</div>
<div id="what-about-the-video" class="section level3">
<h3>What about the video?</h3>
<p>For any project like this I simply drop each of the three sequences of sequentially numbered png files onto its own timeline track as a still image sequence in a standard video editor. I don’t use R for this final step. While I could have plotted everything together on a single sequence of frames, it doesn’t make sense to do so even when each sequence has equal length. This is because one sequence may take far longer to plot than another sequence. It is more efficient to make a different image sequence for separate layers and mix them in the editor afterward.</p>
<p>You might also notice the very high pixel dimensions of the png outputs. I do this in cases where I plan to zoom during an animation. The larger the image, the more I can zoom in without degradation. You can imagine that this generates a lot of data when you have thousands of frames and each image is several megabytes.</p>
</div>
<div id="conclusion-dont-try-this-at-home" class="section level3">
<h3>Conclusion: Don’t try this at home</h3>
<p>Instead, try something like this on a server with plenty of CPUs and RAM. Otherwise try it with a small data set. Due to the particular computing environment I used and the resources needed to process the frames in an efficient and timely fashion, it is impossible to share this example animation code in a completely reproducible fashion. However, you should be able to use <code>df_segs</code> or some alteration of it with a properly formatted input table to generate the type of table you would want to pass subsequently to <code>save_maps</code> (or some alteration of that as well).</p>
<p>That is the gist of this example and should be enough to get you started. Ultimately, you will have to adapt any code here to your unique data, its size and complexity, what exactly you want to do with it, and your available computing resources.</p>
</div>
</div>

<!-- some extra javascript for older browsers -->
<script type="text/javascript" src="libs/polyfill.js"></script>
<script>
  // manage active state of menu based on current page
  $(document).ready(function () {

    // active menu
    href = window.location.pathname
    href = href.substr(href.lastIndexOf('/') + 1)
    $('a[href="' + href + '"]').parent().addClass('active');

    // manage active menu header
    if (href.startsWith('authoring_'))
      $('a[href="' + 'authoring' + '"]').parent().addClass('active');
    else if (href.endsWith('_format.html'))
      $('a[href="' + 'formats' + '"]').parent().addClass('active');
    else if (href.startsWith('developer_'))
      $('a[href="' + 'developer' + '"]').parent().addClass('active');

  });
</script>



</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
